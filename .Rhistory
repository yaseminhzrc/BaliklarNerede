p_ship_track+p_bathymetry
# Read in the acoustic data
acoustic<-read_csv("C:/Users/yasem/OneDrive/Masaüstü/proje/acoustic.csv",
col_types=cols(Date_M=col_datetime(format="%Y%m%d")))%>%  #Date_M değişkeni  Yıl,ay,gün olarak tarih formatına dönüştürüldü.
filter(Lon_M !=999.0) #Lon_M 999.0 a eşit olamayanlar filtrelendi.
# Glimpse the data
glimpse(acoustic)
# Create a list of variables to keep
variables_keep <- c("Interval", "Layer", "Sv_mean", "Frequency",
"Date_M", "Time_S", "Time_E", "Lat_M", "Lon_M")
# Select and filter the data
Sv_layer1 <- acoustic %>%
select(one_of(variables_keep)) %>%
rename(Spatial_interval = Interval, Date = Date_M) %>%
filter(Layer == "1")  %>%
mutate(Datetime_start = Date + Time_S,
Datetime_end = Date + Time_E)  %>%
arrange(Datetime_start) #Datetime_start artan sırada ayarlandı.
# Glimpse the cleaned acoustic data
glimpse(Sv_layer1)
# Data prep for temporal interval join
Sv <- Sv_layer1 %>%
mutate(Distance_between = c(0,
geosphere::distHaversine(cbind(Lon_M[-n()], Lat_M[-n()]),
cbind(Lon_M[  -1], Lat_M[  -1]))), #aradaki mesafe bulundu.
Distance_along = cumsum(Distance_between)) %>% #Distance_between ile kümülatif toplamlar bulundu ve Distance_along oluşturuldu.
na_if(-999) %>%  #-999'un NA oldugu belirtildi.
mutate(Time_interval = interval(Datetime_start, Datetime_end)) #interval() başlangıç ve bitiş tarihlerini yan yana getirerek birleştirdi ve Time_interval oluşturuldu.
# Glimpse the data
glimpse(Sv)
# Name the function
get_Interval_by_time <- function(bottom_data){
res <- Sv$Spatial_interval[bottom_data%within%Sv$Time_interval]
if(length(res)==0) return(NA)         # dealing with NAs
return(res)
}
# Map the track line interval value to the bottom_clean data
bottom_spatial_interval_segments <- bottom_clean  %>%
mutate(trackline_interval = purrr::map_dbl(date_time, get_Interval_by_time))
# Inspect the first 15 rows
head(bottom_spatial_interval_segments, 15)
# Group bottom_clean and calculate the mean depth
bottom_intervals<-bottom_spatial_interval_segments %>%
group_by(trackline_interval) %>%
summarize(depth_mean=mean(depth)) %>%
ungroup()
#Join the bottom intervals data to the acoustic data
Sv_and_depth<-Sv %>%
left_join(bottom_intervals,by=c("Spatial_interval"="trackline_interval")) %>%
mutate(depth_plot=ifelse(depth_mean >=250,250,depth_mean))
#Glimpse the data
glimpse(Sv_and_depth)
# Top panel
Sv_mean_plot<-ggplot(Sv_and_depth, aes(Distance_along,Sv_mean))+
geom_line()+
labs(y=expression(mean~volume~backscatter~s[v]~(dB)))+
theme(axis.title.x=element_blank())
# Bottom panel
bathymetry<-ggplot(Sv_and_depth,aes(Distance_along,depth_plot))+
geom_line(size=0.5)+
scale_y_reverse()+
labs(x="Distance along trackline (m)",y="Depth(m)")
# Display the two panels in one figure
Sv_mean_plot/bathymetry
# Where do you think the fish are along this track line?
# Options:Shelf,Shelf Break ,Offshore
(where_are_the_fishes<-"Shelf")
variables_keep
# Tutulacak değişkenlerin bir listesini oluşturun
variables_keep <- c("Interval", "Layer", "Sv_mean", "Frequency",
"Date_M", "Time_S", "Time_E", "Lat_M", "Lon_M")   #Kullanılacak değişkenler variables_keep olarak alındı.
# Verileri seçin ve filtreleyin
Sv_layer1 <- acoustic %>%
select(one_of(variables_keep)) %>%  #Variables_keep deki değişkenelr seçildi
rename(Spatial_interval = Interval, Date = Date_M) %>% #isim değişiklikleri yapıldı.
filter(Layer == "1")  %>%   #Layer 1 e eşit olan satırlar filtrelendi.
mutate(Datetime_start = Date + Time_S,
Datetime_end = Date + Time_E)  %>%
arrange(Datetime_start) #Datetime_start artan sırada ayarlandı.
# Glimpse the cleaned acoustic data
glimpse(Sv_layer1)
acoustic
# Tutulacak değişkenlerin bir listesini oluşturun
variables_keep <- c("Interval", "Layer", "Sv_mean", "Frequency",
"Date_M", "Time_S", "Time_E", "Lat_M", "Lon_M")   #Kullanılacak değişkenler variables_keep olarak alındı.
# Verileri seçin ve filtreleyin
Sv_layer1 <- acoustic %>%
select(one_of(variables_keep)) %>%  #Variables_keep deki değişkenelr seçildi
rename(Spatial_interval = Interval, Date = Date_M) %>% #isim değişiklikleri yapıldı.
filter(Layer == "1")  %>%   #Layer 1 e eşit olan satırlar filtrelendi.
mutate(Datetime_start = Date + Time_S, #Tarih ve başlangıç saati birleştirilerek Datetime_start oluşturuldu.
Datetime_end = Date + Time_E)  %>% #Tarih ve bitiş saati birleştirilerek Datetime_end oluşturuldu.
arrange(Datetime_start) #Datetime_start artan sırada ayarlandı.
# Glimpse the cleaned acoustic data
glimpse(Sv_layer1)
knitr::opts_chunk$set(echo = TRUE)
get_Interval_by_time <- function(bottom_data){
res <- Sv$Spatial_interval[bottom_data%within%Sv$Time_interval]
if(length(res)==0) return(NA)         # NA lar
return(res)
}
Sv$Spatial_interval
Sv$Time_interval
Sv$Spatial_interval
res
# İşlevi adlandırın.
get_Interval_by_time <- function(bottom_data){
res <- Sv$Spatial_interval[bottom_data%within%Sv$Time_interval]
if(length(res)==0) return(NA)         # NA lar
return(res)
}
res
# İşlevi adlandırın.
get_Interval_by_time <- function(bottom_data){
res <- Sv$Spatial_interval[bottom_data%within%Sv$Time_interval]
if(length(res)==0) return(NA)         # NA lar
return(res)
}
# Rota çizgisi aralığı değerini bottom_clean verilerine eşleyin.
bottom_spatial_interval_segments <- bottom_clean  %>%
mutate(trackline_interval = purrr::map_dbl(date_time, get_Interval_by_time))
knitr::opts_chunk$set(echo = TRUE)
# Paketleri Yükleyelim
library(tidyverse)
library(dplyr)
library(readr)
library(lubridate)
library(ggplot2)
library(patchwork)
library(geosphere)
library(gridExtra)
library(purrr)
# Derinlik verilerini okutalım
bottom<-read_csv("C:/Users/yasem/OneDrive/Masaüstü/proje/bottom_line.csv",
col_types = cols(Ping_date=col_datetime(format="%m/%d/%Y")))%>% #Ping_date degişkeni ay,gün,yıl olarak tarih formatına dönüştürüldü.
rename_all(tolower) #rename_all tüm değişken isimlerine bir işlem uygulamak için kullanılır.Tüm değişken isimleri küçük harfe dönüştürüldü.
glimpse(bottom) #verinin yapısını inceleyeceğiz.
# Derinlik verilerini temizleyelim
bottom_clean<-bottom %>%
filter(position_status==1)%>%   #position_status 1 e eşit olan satırlar filtrelendi.
select(ping_date,ping_time,latitude,longitude,depth)%>% #talimatlarda belirtilen değişkenler seçildi.
mutate(date_time=ping_date + ping_time,     #tarih ve saat değişkenleri birleştirilerek date_time değişkeni oluşturuldu.
distance_between=c(0,
geosphere::distHaversine(cbind(longitude[-n()],latitude[-n()]), #longitude=boylam, latitude=enlem
cbind(longitude[ -1],latitude[ -1]))), #distHaversine komutu ile enlem ve boylam arasındaki mesafe bulundu ve bu şekilde distance_between oluşturuldu.
distance_along=cumsum(distance_between)) #distance_between değişkeninin kümülatif toplamları ile distance_along oluşturuldu.
# Veriyi inceleyelim
glimpse(bottom_clean) #değişkenlerin yapısına bakalım
# Grafiklerin boyutunu ayarlayalım
options(repr.plot.width=7, repr.plot.height=5) #Grafiklerin genişlik ve yüksekliği ayarlandı.
# Geminin rotasını çizelim
p_ship_track <-ggplot(bottom_clean, aes(longitude,latitude))+ #x ekseninde boylam, y ekseninde enlem olacak şekilde grafik oluşturuluyor.
geom_point(size=0.5)+ #nokta grafiği çizdirilecektir ve nokta büyüklüğü ayarlanıyor.
labs(x="Longitude",y="Latitude") #x vey eksenlerine değişkenlerin isimleri verildi.
# Geminin yolu boyunca deniz tabanının derinliğini çizin.
p_bathymetry<-ggplot(bottom_clean,aes(distance_along,depth))+ #distance_along=geminin yolu,depth=derinlik
geom_point(size=0.5)+
scale_y_reverse()+  #y ekseni ters çevriliyor
labs(x="Distance along trackline (m)",y="Depth (m)")  #x ve y eksenleri isimlendirildi.
# Grafikleri yan yana çizdirelim.
p_ship_track+p_bathymetry
# Akustik veriyi okutalım
acoustic<-read_csv("C:/Users/yasem/OneDrive/Masaüstü/proje/acoustic.csv",
col_types=cols(Date_M=col_datetime(format="%Y%m%d")))%>%  #Date_M değişkeni  Yıl,ay,gün olarak tarih formatına dönüştürüldü.
filter(Lon_M !=999.0) #Lon_M 999.0 a eşit olamayanlar filtrelendi.
# Verinin yapısını inceleyelim
glimpse(acoustic)
# Tutulacak değişkenlerin bir listesini oluşturun
variables_keep <- c("Interval", "Layer", "Sv_mean", "Frequency",
"Date_M", "Time_S", "Time_E", "Lat_M", "Lon_M")   #Kullanılacak değişkenler variables_keep olarak alındı.
# Verileri seçin ve filtreleyin
Sv_layer1 <- acoustic %>%
select(one_of(variables_keep)) %>%  #Variables_keep deki değişkenelr seçildi
rename(Spatial_interval = Interval, Date = Date_M) %>% #isim değişiklikleri yapıldı.
filter(Layer == "1")  %>%   #Layer 1 e eşit olan satırlar filtrelendi.
mutate(Datetime_start = Date + Time_S, #Tarih ve başlangıç saati birleştirilerek Datetime_start oluşturuldu.
Datetime_end = Date + Time_E)  %>% #Tarih ve bitiş saati birleştirilerek Datetime_end oluşturuldu.
arrange(Datetime_start) #Datetime_start artan sırada ayarlandı.
# Temizlenmiş akustik verilere bir göz atalım.
glimpse(Sv_layer1)
# Geçici aralık birleştirme için veri hazırlığı
Sv <- Sv_layer1 %>%
mutate(Distance_between = c(0,
geosphere::distHaversine(cbind(Lon_M[-n()], Lat_M[-n()]),
cbind(Lon_M[  -1], Lat_M[  -1]))), #aradaki mesafe bulundu.
Distance_along = cumsum(Distance_between)) %>% #Distance_between için kümülatif toplamlar bulundu ve Distance_along oluşturuldu.
na_if(-999) %>%  #-999'un NA oldugu belirtildi.
mutate(Time_interval = interval(Datetime_start, Datetime_end)) #interval() başlangıç ve bitiş tarihlerini yan yana getirerek birleştirdi ve Time_interval oluşturuldu.
# Veriyi inceleyelim
glimpse(Sv)
# İşlevi adlandırın.
get_Interval_by_time <- function(bottom_data){
res <- Sv$Spatial_interval[bottom_data%within%Sv$Time_interval]
if(length(res)==0) return(NA)         # NA lar
return(res)
}
# Rota çizgisi aralığı değerini bottom_clean verilerine eşleyin.
bottom_spatial_interval_segments <- bottom_clean  %>%
mutate(trackline_interval = purrr::map_dbl(date_time, get_Interval_by_time))
# İlk 15 satırı inceleyin.
head(bottom_spatial_interval_segments, 15)
# İşlevi adlandırın.
get_Interval_by_time <- function(bottom_data){
res <- Sv$Spatial_interval[bottom_data%within%Sv$Time_interval]
if(length(res)==0) return(NA)         # NA lar
return(res)
}
# Rota çizgisi aralığı değerini bottom_clean verilerine eşleyin.
bottom_spatial_interval_segments <- bottom_clean  %>%
mutate(trackline_interval = purrr::map_dbl(date_time, get_Interval_by_time))
# İlk 15 satırı inceleyin.
head(bottom_spatial_interval_segments, 15)
knitr::opts_chunk$set(echo = TRUE)
# Paketleri Yükleyelim
library(tidyverse)
library(dplyr)
library(readr)
library(lubridate)
library(ggplot2)
library(patchwork)
library(geosphere)
library(gridExtra)
library(purrr)
# Derinlik verilerini okutalım
bottom<-read_csv("C:/Users/yasem/OneDrive/Masaüstü/proje/bottom_line.csv",
col_types = cols(Ping_date=col_datetime(format="%m/%d/%Y")))%>% #Ping_date degişkeni ay,gün,yıl olarak tarih formatına dönüştürüldü.
rename_all(tolower) #rename_all tüm değişken isimlerine bir işlem uygulamak için kullanılır.Tüm değişken isimleri küçük harfe dönüştürüldü.
glimpse(bottom) #verinin yapısını inceleyeceğiz.
# Derinlik verilerini temizleyelim
bottom_clean<-bottom %>%
filter(position_status==1)%>%   #position_status 1 e eşit olan satırlar filtrelendi.
select(ping_date,ping_time,latitude,longitude,depth)%>% #talimatlarda belirtilen değişkenler seçildi.
mutate(date_time=ping_date + ping_time,     #tarih ve saat değişkenleri birleştirilerek date_time değişkeni oluşturuldu.
distance_between=c(0,
geosphere::distHaversine(cbind(longitude[-n()],latitude[-n()]), #longitude=boylam, latitude=enlem
cbind(longitude[ -1],latitude[ -1]))), #distHaversine komutu ile enlem ve boylam arasındaki mesafe bulundu ve bu şekilde distance_between oluşturuldu.
distance_along=cumsum(distance_between)) #distance_between değişkeninin kümülatif toplamları ile distance_along oluşturuldu.
# Veriyi inceleyelim
glimpse(bottom_clean) #değişkenlerin yapısına bakalım
# Grafiklerin boyutunu ayarlayalım
options(repr.plot.width=7, repr.plot.height=5) #Grafiklerin genişlik ve yüksekliği ayarlandı.
# Geminin rotasını çizelim
p_ship_track <-ggplot(bottom_clean, aes(longitude,latitude))+ #x ekseninde boylam, y ekseninde enlem olacak şekilde grafik oluşturuluyor.
geom_point(size=0.5)+ #nokta grafiği çizdirilecektir ve nokta büyüklüğü ayarlanıyor.
labs(x="Longitude",y="Latitude") #x vey eksenlerine değişkenlerin isimleri verildi.
# Geminin yolu boyunca deniz tabanının derinliğini çizin.
p_bathymetry<-ggplot(bottom_clean,aes(distance_along,depth))+ #distance_along=geminin yolu,depth=derinlik
geom_point(size=0.5)+
scale_y_reverse()+  #y ekseni ters çevriliyor
labs(x="Distance along trackline (m)",y="Depth (m)")  #x ve y eksenleri isimlendirildi.
# Grafikleri yan yana çizdirelim.
p_ship_track+p_bathymetry
# Akustik veriyi okutalım
acoustic<-read_csv("C:/Users/yasem/OneDrive/Masaüstü/proje/acoustic.csv",
col_types=cols(Date_M=col_datetime(format="%Y%m%d")))%>%  #Date_M değişkeni  Yıl,ay,gün olarak tarih formatına dönüştürüldü.
filter(Lon_M !=999.0) #Lon_M 999.0 a eşit olamayanlar filtrelendi.
# Verinin yapısını inceleyelim
glimpse(acoustic)
# Tutulacak değişkenlerin bir listesini oluşturun
variables_keep <- c("Interval", "Layer", "Sv_mean", "Frequency",
"Date_M", "Time_S", "Time_E", "Lat_M", "Lon_M")   #Kullanılacak değişkenler variables_keep olarak alındı.
# Verileri seçin ve filtreleyin
Sv_layer1 <- acoustic %>%
select(one_of(variables_keep)) %>%  #Variables_keep deki değişkenelr seçildi
rename(Spatial_interval = Interval, Date = Date_M) %>% #isim değişiklikleri yapıldı.
filter(Layer == "1")  %>%   #Layer 1 e eşit olan satırlar filtrelendi.
mutate(Datetime_start = Date + Time_S, #Tarih ve başlangıç saati birleştirilerek Datetime_start oluşturuldu.
Datetime_end = Date + Time_E)  %>% #Tarih ve bitiş saati birleştirilerek Datetime_end oluşturuldu.
arrange(Datetime_start) #Datetime_start artan sırada ayarlandı.
# Temizlenmiş akustik verilere bir göz atalım.
glimpse(Sv_layer1)
# Geçici aralık birleştirme için veri hazırlığı
Sv <- Sv_layer1 %>%
mutate(Distance_between = c(0,
geosphere::distHaversine(cbind(Lon_M[-n()], Lat_M[-n()]),
cbind(Lon_M[  -1], Lat_M[  -1]))), #aradaki mesafe bulundu.
Distance_along = cumsum(Distance_between)) %>% #Distance_between için kümülatif toplamlar bulundu ve Distance_along oluşturuldu.
na_if(-999) %>%  #-999'un NA oldugu belirtildi.
mutate(Time_interval = interval(Datetime_start, Datetime_end)) #interval() başlangıç ve bitiş tarihlerini yan yana getirerek birleştirdi ve Time_interval oluşturuldu.
# Veriyi inceleyelim
glimpse(Sv)
# İşlevi adlandırın.
get_Interval_by_time <- function(bottom_data){
res <- Sv$Spatial_interval[bottom_data%within%Sv$Time_interval]
if(length(res)==0) return(NA)         # NA lar
return(res)
}
# Rota çizgisi aralığı değerini bottom_clean verilerine eşleyin.
bottom_spatial_interval_segments <- bottom_clean  %>%
mutate(trackline_interval = purrr::map_dbl(date_time, get_Interval_by_time)) #map_dbl çift vektörleri döndürür.
# İlk 15 satırı inceleyin.
head(bottom_spatial_interval_segments, 15)
knitr::opts_chunk$set(echo = TRUE)
# Paketleri Yükleyelim
library(tidyverse)
library(dplyr)
library(readr)
library(lubridate)
library(ggplot2)
library(patchwork)
library(geosphere)
library(gridExtra)
library(purrr)
# Derinlik verilerini okutalım
bottom<-read_csv("C:/Users/yasem/OneDrive/Masaüstü/proje/bottom_line.csv",
col_types = cols(Ping_date=col_datetime(format="%m/%d/%Y")))%>% #Ping_date degişkeni ay,gün,yıl olarak tarih formatına dönüştürüldü.
rename_all(tolower) #rename_all tüm değişken isimlerine bir işlem uygulamak için kullanılır.Tüm değişken isimleri küçük harfe dönüştürüldü.
glimpse(bottom) #verinin yapısını inceleyeceğiz.
# Derinlik verilerini temizleyelim
bottom_clean<-bottom %>%
filter(position_status==1)%>%   #position_status 1 e eşit olan satırlar filtrelendi.
select(ping_date,ping_time,latitude,longitude,depth)%>% #talimatlarda belirtilen değişkenler seçildi.
mutate(date_time=ping_date + ping_time,     #tarih ve saat değişkenleri birleştirilerek date_time değişkeni oluşturuldu.
distance_between=c(0,
geosphere::distHaversine(cbind(longitude[-n()],latitude[-n()]), #longitude=boylam, latitude=enlem
cbind(longitude[ -1],latitude[ -1]))), #distHaversine komutu ile enlem ve boylam arasındaki mesafe bulundu ve bu şekilde distance_between oluşturuldu.
distance_along=cumsum(distance_between)) #distance_between değişkeninin kümülatif toplamları ile distance_along oluşturuldu.
# Veriyi inceleyelim
glimpse(bottom_clean) #değişkenlerin yapısına bakalım
# Grafiklerin boyutunu ayarlayalım
options(repr.plot.width=7, repr.plot.height=5) #Grafiklerin genişlik ve yüksekliği ayarlandı.
# Geminin rotasını çizelim
p_ship_track <-ggplot(bottom_clean, aes(longitude,latitude))+ #x ekseninde boylam, y ekseninde enlem olacak şekilde grafik oluşturuluyor.
geom_point(size=0.5)+ #nokta grafiği çizdirilecektir ve nokta büyüklüğü ayarlanıyor.
labs(x="Longitude",y="Latitude") #x vey eksenlerine değişkenlerin isimleri verildi.
# Geminin yolu boyunca deniz tabanının derinliğini çizin.
p_bathymetry<-ggplot(bottom_clean,aes(distance_along,depth))+ #distance_along=geminin yolu,depth=derinlik
geom_point(size=0.5)+
scale_y_reverse()+  #y ekseni ters çevriliyor
labs(x="Distance along trackline (m)",y="Depth (m)")  #x ve y eksenleri isimlendirildi.
# Grafikleri yan yana çizdirelim.
p_ship_track+p_bathymetry
# Akustik veriyi okutalım
acoustic<-read_csv("C:/Users/yasem/OneDrive/Masaüstü/proje/acoustic.csv",
col_types=cols(Date_M=col_datetime(format="%Y%m%d")))%>%  #Date_M değişkeni  Yıl,ay,gün olarak tarih formatına dönüştürüldü.
filter(Lon_M !=999.0) #Lon_M 999.0 a eşit olamayanlar filtrelendi.
# Verinin yapısını inceleyelim
glimpse(acoustic)
# Tutulacak değişkenlerin bir listesini oluşturun
variables_keep <- c("Interval", "Layer", "Sv_mean", "Frequency",
"Date_M", "Time_S", "Time_E", "Lat_M", "Lon_M")   #Kullanılacak değişkenler variables_keep olarak alındı.
# Verileri seçin ve filtreleyin
Sv_layer1 <- acoustic %>%
select(one_of(variables_keep)) %>%  #Variables_keep deki değişkenelr seçildi
rename(Spatial_interval = Interval, Date = Date_M) %>% #isim değişiklikleri yapıldı.
filter(Layer == "1")  %>%   #Layer 1 e eşit olan satırlar filtrelendi.
mutate(Datetime_start = Date + Time_S, #Tarih ve başlangıç saati birleştirilerek Datetime_start oluşturuldu.
Datetime_end = Date + Time_E)  %>% #Tarih ve bitiş saati birleştirilerek Datetime_end oluşturuldu.
arrange(Datetime_start) #Datetime_start artan sırada ayarlandı.
# Temizlenmiş akustik verilere bir göz atalım.
glimpse(Sv_layer1)
# Geçici aralık birleştirme için veri hazırlığı
Sv <- Sv_layer1 %>%
mutate(Distance_between = c(0,
geosphere::distHaversine(cbind(Lon_M[-n()], Lat_M[-n()]),
cbind(Lon_M[  -1], Lat_M[  -1]))), #aradaki mesafe bulundu.
Distance_along = cumsum(Distance_between)) %>% #Distance_between için kümülatif toplamlar bulundu ve Distance_along oluşturuldu.
na_if(-999) %>%  #-999'un NA oldugu belirtildi.
mutate(Time_interval = interval(Datetime_start, Datetime_end)) #interval() başlangıç ve bitiş tarihlerini yan yana getirerek birleştirdi ve Time_interval oluşturuldu.
# Veriyi inceleyelim
glimpse(Sv)
Sv$Spatial_interval
Sv
# İşlevi adlandırın.
get_Interval_by_time <- function(bottom_data){
res <- Sv$Spatial_interval[bottom_data%within%Sv$Time_interval]
if(length(res)==0) return(NA)         # NA lar
return(res)
}
# Rota çizgisi aralığı değerini bottom_clean verilerine eşleyin.
bottom_spatial_interval_segments <- bottom_clean  %>%
mutate(trackline_interval = purrr::map_dbl(date_time, get_Interval_by_time)) #map_dbl çift vektörleri döndürür.
# İlk 15 satırı inceleyin.
head(bottom_spatial_interval_segments, 15)
Sv
# İşlevi adlandırın.
get_Interval_by_time <- function(bottom_data){
res <- Sv$Spatial_interval[bottom_data%within%Sv$Time_interval]
if(length(res)==0) return(NA)         # NA lar
return(res)
}
# Rota çizgisi aralığı değerini bottom_clean verilerine eşleyin.
bottom_spatial_interval_segments <- bottom_clean  %>%
mutate(trackline_interval = purrr::map_dbl(date_time, get_Interval_by_time)) #map_dbl çift vektörleri döndürür.
# İlk 15 satırı inceleyin.
head(bottom_spatial_interval_segments, 15)
bottom_intervals<-bottom_spatial_interval_segments %>%
group_by(trackline_interval) %>% #veriyi trackline_interval ile grupluyoruz.
summarize(depth_mean=mean(depth)) %>% #derinliğin ortalamasını
ungroup()
knitr::opts_chunk$set(echo = TRUE)
# Paketleri Yükleyelim
library(tidyverse)
library(dplyr)
library(readr)
library(lubridate)
library(ggplot2)
library(patchwork)
library(geosphere)
library(gridExtra)
library(purrr)
# Derinlik verilerini okutalım
bottom<-read_csv("C:/Users/yasem/OneDrive/Masaüstü/proje/bottom_line.csv",
col_types = cols(Ping_date=col_datetime(format="%m/%d/%Y")))%>% #Ping_date degişkeni ay,gün,yıl olarak tarih formatına dönüştürüldü.
rename_all(tolower) #rename_all tüm değişken isimlerine bir işlem uygulamak için kullanılır.Tüm değişken isimleri küçük harfe dönüştürüldü.
glimpse(bottom) #verinin yapısını inceleyeceğiz.
# Derinlik verilerini temizleyelim
bottom_clean<-bottom %>%
filter(position_status==1)%>%   #position_status 1 e eşit olan satırlar filtrelendi.
select(ping_date,ping_time,latitude,longitude,depth)%>% #talimatlarda belirtilen değişkenler seçildi.
mutate(date_time=ping_date + ping_time,     #tarih ve saat değişkenleri birleştirilerek date_time değişkeni oluşturuldu.
distance_between=c(0,
geosphere::distHaversine(cbind(longitude[-n()],latitude[-n()]), #longitude=boylam, latitude=enlem
cbind(longitude[ -1],latitude[ -1]))), #distHaversine komutu ile enlem ve boylam arasındaki mesafe bulundu ve bu şekilde distance_between oluşturuldu.
distance_along=cumsum(distance_between)) #distance_between değişkeninin kümülatif toplamları ile distance_along oluşturuldu.
# Veriyi inceleyelim
glimpse(bottom_clean) #değişkenlerin yapısına bakalım
# Grafiklerin boyutunu ayarlayalım
options(repr.plot.width=7, repr.plot.height=5) #Grafiklerin genişlik ve yüksekliği ayarlandı.
# Geminin rotasını çizelim
p_ship_track <-ggplot(bottom_clean, aes(longitude,latitude))+ #x ekseninde boylam, y ekseninde enlem olacak şekilde grafik oluşturuluyor.
geom_point(size=0.5)+ #nokta grafiği çizdirilecektir ve nokta büyüklüğü ayarlanıyor.
labs(x="Longitude",y="Latitude") #x vey eksenlerine değişkenlerin isimleri verildi.
# Geminin yolu boyunca deniz tabanının derinliğini çizin.
p_bathymetry<-ggplot(bottom_clean,aes(distance_along,depth))+ #distance_along=geminin yolu,depth=derinlik
geom_point(size=0.5)+
scale_y_reverse()+  #y ekseni ters çevriliyor
labs(x="Distance along trackline (m)",y="Depth (m)")  #x ve y eksenleri isimlendirildi.
# Grafikleri yan yana çizdirelim.
p_ship_track+p_bathymetry
# Akustik veriyi okutalım
acoustic<-read_csv("C:/Users/yasem/OneDrive/Masaüstü/proje/acoustic.csv",
col_types=cols(Date_M=col_datetime(format="%Y%m%d")))%>%  #Date_M değişkeni  Yıl,ay,gün olarak tarih formatına dönüştürüldü.
filter(Lon_M !=999.0) #Lon_M 999.0 a eşit olamayanlar filtrelendi.
# Verinin yapısını inceleyelim
glimpse(acoustic)
# Tutulacak değişkenlerin bir listesini oluşturun
variables_keep <- c("Interval", "Layer", "Sv_mean", "Frequency",
"Date_M", "Time_S", "Time_E", "Lat_M", "Lon_M")   #Kullanılacak değişkenler variables_keep olarak alındı.
# Verileri seçin ve filtreleyin
Sv_layer1 <- acoustic %>%
select(one_of(variables_keep)) %>%  #Variables_keep deki değişkenelr seçildi
rename(Spatial_interval = Interval, Date = Date_M) %>% #isim değişiklikleri yapıldı.
filter(Layer == "1")  %>%   #Layer 1 e eşit olan satırlar filtrelendi.
mutate(Datetime_start = Date + Time_S, #Tarih ve başlangıç saati birleştirilerek Datetime_start oluşturuldu.
Datetime_end = Date + Time_E)  %>% #Tarih ve bitiş saati birleştirilerek Datetime_end oluşturuldu.
arrange(Datetime_start) #Datetime_start artan sırada ayarlandı.
# Temizlenmiş akustik verilere bir göz atalım.
glimpse(Sv_layer1)
# Geçici aralık birleştirme için veri hazırlığı
Sv <- Sv_layer1 %>%
mutate(Distance_between = c(0,
geosphere::distHaversine(cbind(Lon_M[-n()], Lat_M[-n()]),
cbind(Lon_M[  -1], Lat_M[  -1]))), #aradaki mesafe bulundu.
Distance_along = cumsum(Distance_between)) %>% #Distance_between için kümülatif toplamlar bulundu ve Distance_along oluşturuldu.
na_if(-999) %>%  #-999'un NA oldugu belirtildi.
mutate(Time_interval = interval(Datetime_start, Datetime_end)) #interval() başlangıç ve bitiş tarihlerini yan yana getirerek birleştirdi ve Time_interval oluşturuldu.
# Veriyi inceleyelim
glimpse(Sv)
# İşlevi adlandırın.
get_Interval_by_time <- function(bottom_data){
res <- Sv$Spatial_interval[bottom_data%within%Sv$Time_interval] #veriye Sv verisindeki Time_interval aralıklarına göre Sv deki Spatial_interval değerlerini atayacak bir fonksiyon oluşturuldu.
if(length(res)==0) return(NA)         # NA lar
return(res)
}
# Rota çizgisi aralığı değerini bottom_clean verilerine eşleyin.
bottom_spatial_interval_segments <- bottom_clean  %>%
mutate(trackline_interval = purrr::map_dbl(date_time, get_Interval_by_time)) #map_dbl çift vektörleri döndürür.
# date_time değişkenine fonksiyon uygulandı ve trackline_interval oluşturuldu.
# İlk 15 satırı inceleyin.
head(bottom_spatial_interval_segments, 15)
bottom_intervals<-bottom_spatial_interval_segments %>%
group_by(trackline_interval) %>% #veriyi trackline_interval ile grupluyoruz.
summarize(depth_mean=mean(depth)) %>% #derinliğin ortalamasını
ungroup()
# Bottom_clean'i gruplayın ve ortalama derinliği hesaplayın
bottom_intervals<-bottom_spatial_interval_segments %>%
group_by(trackline_interval) %>% #veriyi trackline_interval ile grupluyoruz.
summarize(depth_mean=mean(depth)) %>% #derinliğin ortalamasını
ungroup()
#Join the bottom intervals data to the acoustic data
Sv_and_depth<-Sv %>%
left_join(bottom_intervals,by=c("Spatial_interval"="trackline_interval")) %>%
mutate(depth_plot=ifelse(depth_mean >=250,250,depth_mean))
#Glimpse the data
glimpse(Sv_and_depth)
bottom_intervals
Sv
Sv_and_depth
# Bottom_clean'i gruplayın ve ortalama derinliği hesaplayın
bottom_intervals<-bottom_spatial_interval_segments %>%
group_by(trackline_interval) %>% #veriyi trackline_interval ile grupluyoruz.
summarize(depth_mean=mean(depth)) %>% #derinliğin ortalamasını bulup depth_mean a eşitliyoruz.
ungroup()
#Bottom_intervals verilerini akustik veriyle birleştirin
Sv_and_depth<-Sv %>%
left_join(bottom_intervals,by=c("Spatial_interval"="trackline_interval")) %>% #bottom_intervals verisindeki tracline_interval değişkeninin ismi Sv verisi ile ortak olması için "Spatial_inyterval ismi ile değiştirildi.ve iki veri birleştirildi.
mutate(depth_plot=ifelse(depth_mean >=250,250,depth_mean))#250 den büyük her ortalama derinlik değeri 250 oldu ve bu şekilde depth_plot değişkeni oluşturuldu.
# Veriyi inceleyelim
glimpse(Sv_and_depth)
# Üst panel
Sv_mean_plot<-ggplot(Sv_and_depth, aes(Distance_along,Sv_mean))+
geom_line()+
labs(y=expression(mean~volume~backscatter~s[v]~(dB)))+
theme(axis.title.x=element_blank())
# Alt panel
bathymetry<-ggplot(Sv_and_depth,aes(Distance_along,depth_plot))+
geom_line(size=0.5)+
scale_y_reverse()+   #y ekseni ters çevrildi.
labs(x="Distance along trackline (m)",y="Depth(m)")  #x ve y ekseni isimlendirildi.
# İki paneli tek bir şekilde görüntüleyin
Sv_mean_plot/bathymetry

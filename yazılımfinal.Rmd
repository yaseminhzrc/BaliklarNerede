---
title: "Untitled"
author: "Yasemin Hızarcı"
date: "06 01 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# BALIKLAR NEREDE?

**ABD ATLANTIK OKYANUSU'NDA BALIK BULMAK IÇIN AKUSTIK GERI SAÇILIM VERILERINI KEŞFEDİLMESİ**
Yansımalar. Hayır, Tidyverse'teki varlığınızı düşünmekten veya bu spline'ın verilerinize ne yaptığını anlamaktan bahsetmiyorum. Ben ekolardan bahsediyorum. Özellikle, "geri saçılma" adı verilen akustik yankılar. Deniz bilimcileri, okyanustaki organizmaların dağılımını anlamak için akustik geri saçılım kullanırlar.

Bu analizde, aktif akustik verileri tartışacağız ve batimetri (deniz tabanının derinliği) ile ilişkili olarak yüzme keseli balıklarla ilişkili ortalama hacim geri saçılımını çizeceğiz.

Bu akustik veriler, Orta Atlantik Körfezi'ndeki (NOAA seyir HB1103) raf kırılmasını geçen bir araştırma gemisinden toplandı ve Echoview yazılımı kullanılarak ön işlemden geçirildi.

**TALİMATLAR**

Kitaplıkları ve derinlik verilerini yükleyin.

Aşağıdaki paketleri yükleyin: dplyr, readr, lubridate, ggplot2, ve patchwork.

Derinlik verilerini okuyun datasets/bottom_line.csv, kullanın read_csv()ve atayın bottom. ping_dateAy / gün / 4 basamaklı yıl için doğru biçimi kullanın ve tüm değişkenleri küçük harfle yazın.

glimpse()Ham verilerin yapısına ve ilk birkaç gözlemine bakmak için kullanın .

Bu proje 16 Aralık 2019'da güncellendi. Projeye bu tarihten önce başladıysanız, projeyi sıfırlamak için lütfen ekranın sağ alt köşesindeki dairesel oka tıklayın. Kodunuzu kaydetmek istiyorsanız, sıfırlamadan önce projenizi indirin.

Bunu bildiğim iyi oldu​

Bu projede, sen öğretilen becerilerini edeceğiz Tidyverse içinde Verilerle Çalışma ve R Tarihler ve saatlerle çalışma . Sen bir fonksiyonu kullanarak veri kümelerini, enlem ve boylam gelen hesaplamak mesafeler katılacak geospherepaketi ve basit görselleştirme yapmak ggplot2ve patchwork.

Çoğul balık balıktır. Balıklar , birden fazla balık türünü ifade eder.



#1)BACKSCATTER(GERİ SAÇILMA) - OKYANUSTA UZAKTAN ALGILAMA





# **1.AŞAMA**

```{r message=FALSE, warning=FALSE}

# Load the Libraries
library(tidyverse)
library(dplyr)
library(readr)
library(lubridate)
library(ggplot2)
library(patchwork)
library(geosphere)
library(gridExtra)
library(purrr)

```
```{r}
# Read in the depth data

bottom<-read_csv("C:/Users/yasem/OneDrive/Masaüstü/proje/bottom_line.csv", 
                 col_types = cols(Ping_date=col_datetime(format="%m/%d/%Y")))%>%
  rename_all(tolower)

glimpse(bottom)
```

# **2.AŞAMA**

**AÇIKLAMA**

2)"SHELF BREAK"(RAF MOLASI NEDİR?)

Soldaki haritadaki kırmızı çizgi, geminin Orta Atlantik Körfezi'ndeki raf molası boyunca izlediği yol. Ama "raf molası" nedir? Bir uçurumun su altı versiyonu.

Çoğu deniz ekosisteminde, raf kırılması aynı zamanda birçok türe yiyecek ve yaşam alanı sağlayan oldukça dinamik ve verimli bir alandır. En küçük fitoplanktonlardan en büyük deniz memelilerine, köpekbalıklarına, deniz kuşlarına, tunalara ve deniz kaplumbağalarına kadar hepsi bu alanı yaşam döngülerinin bir noktasında kullanırlar. Ve bu harika bölgeden bazı aktif akustik verilerle oynayacağız!​
​
Ama önce batimetri (derinlik) verilerini temizleyelim ve çizim için hazırlayalım.


**tALİMATLAR**

Alttaki verileri temizleyin.​

Noktaları tutmak için derinlik verileri Filtre position_statussütunlar 1 eşittir ve seçin: ping_date, ping_time, latitude, longitude, ve depth.​

Aynı boru zincirinde, ve date_timeekleyerek yeni bir tarih saat sütunu oluşturun .ping_dateping_time​

glimpse()Temizlenmiş verilerin yapısına ve ilk birkaç gözlemine bakmak için kullanın .

distance_betweenher GPS konumu (boylam ve enlem) arasındaki mesafedir (metre).

```{r}
# Clean the bottom data

bottom_clean<-bottom %>%
filter(position_status==1)%>%
select(ping_date,ping_time,latitude,longitude,depth)%>%
mutate(date_time=ping_date + ping_time,
         distance_between=c(0,
                            geosphere::distHaversine(cbind(longitude[-n()],latitude[-n()]),
                                                     cbind(longitude[ -1],latitude[ -1]))),
         distance_along=cumsum(distance_between))

# Inspect the data

glimpse(bottom_clean)
```

# **3. AŞAMA**

**açıklamalar**

3. NEREYE GİDERSEN GİT, ORADASIN

Artık kötü veri noktalarını kaldırdığımıza ve geminin kat ettiği kümülatif mesafeyi hesapladığımıza göre, verileri planlayalım.​
​
Geminin rotasının yatay görünümü, geminin ray hattından sapıp sapmadığını veya verilerde herhangi bir kesinti olup olmadığını bize gösterecektir.​
​
Ray çizgisi boyunca deniz tabanının derinliğinin bir grafiği bize raf kırılmasının konumunu gösterecektir. İzleme hattı verilerinin uzamsal analizinde, genellikle sp ve sf paketlerinde çalışırdık, ancak bu kendi başına bir konudur. Şimdilik, iz çizgisi boyunca enlem, boylam, derinlik ve mesafe ile birkaç iz çizgisi grafiği oluşturacağız.

**talimatlar**

Temizlenmiş dip verilerinin grafiğini çizelim!​

Daha kolay görüntüleme için grafiklerin boyutunu değiştirin. Kod verilir.​

Boylam (x) ve enlem (y) için bir nokta grafiği yapın ve noktaların boyutunu 0,5 olarak ayarlayın.​

İz çizgisi (x) ve derinlik (y) boyunca bir mesafe nokta grafiği yapın ve noktaların boyutunu 0,5 olarak ayarlayın. Y eksenini ile ters çevirin scale_y_reverse().​

İle patchworkgrafikleri yan yana düzenleyebilirsiniz +. Kod verilir.

Sözleşmeye göre deniz yüzeyi 0 metredir. Bu derinlik verileri pozitif olduğu için y ekseninin ters çevrilmesi gerekir.

```{r}
# Set the size of the plots

options(repr.plot.width=7, repr.plot.height=5)

# Plot the ship's track

p_ship_track <-ggplot(bottom_clean, aes(longitude,latitude))+
  geom_point(size=0.5)+
  labs(x="Longitude",y="Latitude")

# Plot the depth of the sea floor along the ship's track

p_bathymetry<-ggplot(bottom_clean,aes(distance_along,depth))+
  geom_point(size=0.5)+
  scale_y_reverse()+
  labs(x="Distance along trackline (m)",y="Depth (m)")

# Arrange the plots side by side

p_ship_track+p_bathymetry
```

# **4.AŞAMA**

**AÇIKLAMALAR**

4. BURADA BALIKLAR, BALIKLAR, BALIKLAR

Hacim geri saçılımı (Sv), organizmaların göreceli yoğunluğunun bir ölçüsüdür. Bu durumda, balık benzeri saçılmayı aramak için Echoview'deki verileri önceden işlediğimiz için, hacim geri saçılım verilerinin son grafiği olan Sv_mean, bize balıkların yol çizgisi boyunca dağılımının bir göstergesini verecektir.​
​
Balık olması durumunda, yol hattının daha yüksek / daha düşük yoğunluklu bölümleri olacak mı? Hadi bulalım!

**TALİMATLAR**

​

Akustik verileri yükleyin ve temizleyin.​

Akustik veri oku datasets/acoustic.csvkullanılarak read_csv()ve boru bu için filter()herhangi bir kötü konum verilerini çıkarmak için (örneğin, Lon_M999.0 e eşit değildir). Tarih_M formatı sizin için ayarlandı.​

Yapıya ve bazı değerlere bakmak için yeni verilere göz atın.

Akustik veriler, ızgara hücresi başına üç Boylam / Enlem konumuna sahiptir. Lon_S/ Lat_Sızgara hücresinin başlangıcı için. Lon_M/ Lat_Mızgara hücresinin orta noktası için. Lon_E/ Lat_Eızgara hücresinin uç noktası için.



```{r}

# Read in the acoustic data

acoustic<-read_csv("C:/Users/yasem/OneDrive/Masaüstü/proje/acoustic.csv",
                   col_types=cols(Date_M=col_datetime(format="%Y%m%d")))%>%
  filter(Lon_M !=999.0)

# Glimpse the data
glimpse(acoustic)

```


# **5.AŞAMA**

**AÇIKLAMALAR**

5. BU ÇOK FAZLA DEĞİŞKEN!

Vaov! 78 değişkenin 724 gözlemi! Bu, Echoview'den tam veri dışa aktarımıdır, ancak yalnızca hacim geri saçılım verileri, Sv_mean ve verileri çizmek için gereken diğer birkaç değişkenle ilgilendiğimizi unutmayın.​
​
Bu geri saçılım verileri, geminin yolu boyunca 200 metre (Aralık değişkeninde numaralandırılmış), 250 metre derinlikte (Katman değişkeninde numaralandırılmıştır), geminin yoluna ve derinliğine atıfta bulunan bir koordinat sistemi oluşturan ızgara hücrelerine entegre edildi. . İlk derinlik katmanını keşfedeceğiz.

**TALİMATLAR**
AKUSTİK VERİLERİ TEMİZLEYİN.

Çağrılacak bir değişkenler listesi oluşturun variables_keep.​

select()Değişkenleri tutmak için ve yardımcısı kullanın variables_keep. Sütun adlarını değiştirin Intervaletmek Spatial_intervalve Date_Mkarşı Datebirlikte rename(). Verileri ilk derinlik katmanından korumak için filtre uygulayın. Tarih sütununu ve doğru zaman sütununu ekleyerek başlangıç ( Datetime_start) ve bitiş ( Datetime_end) zaman damgalarını oluşturun.

Temizlenmiş verilere bir göz atın.​

​

​

Date_Madını değiştirdiğiniz tarih sütunudur Date. Time_Sbaşlangıç zamanı. Time_Ezamanıdır.


```{r}
# Create a list of variables to keep
variables_keep <- c("Interval", "Layer", "Sv_mean", "Frequency", 
               "Date_M", "Time_S", "Time_E", "Lat_M", "Lon_M")

# Select and filter the data 
Sv_layer1 <- acoustic %>%
    select(one_of(variables_keep)) %>% 
    rename(Spatial_interval = Interval, Date = Date_M) %>%
    filter(Layer == "1")  %>% 
    mutate(Datetime_start = Date + Time_S,
           Datetime_end = Date + Time_E)  %>% 
    arrange(Datetime_start) 

# Glimpse the cleaned acoustic data
glimpse(Sv_layer1)
```
# **6. AŞAMA**
6. BİRAZ DAHA ÇEKİŞME

**AÇIKLAMA**

Harika! Bütün bunlar güzelce bir araya geliyor. Bottom_clean'de derinlik, yol çizgisi boyunca mesafe ve zaman damgaları var. Artık zaman damgaları olan ancak iz çizgisi boyunca mesafe ve derinlik bilgisi olmayan (buna bir dakika içinde ulaşacağız) neredeyse temiz bir akustik veri kümesine sahibiz, Sv_layer1. Ayrıca Echoview, NA'ları belirtmek için -999.0 kullanır. Bunları kaldırmamız gerek yoksa geri saçılma planımız biraz riskli görünecek.

Akustik verileri temizleyin.​

Uygun işlevleri oluşturun Distance_betweenve Distance_alongkullanın. Yardıma ihtiyacınız olursa Görev 2'ye tekrar bakın.​

-999.0 değerlerini ile değiştirin ve başlatma ve durdurma zaman damgalarını kullanarak NAçağrılan bir zaman aralığı oluşturun Time_interval.​

Temizlenmiş verilere bir göz atın.

Nokta verisi olan alt verilerden farklı olarak, akustik veriler, ızgara hücresinin başlangıcı, ortası ve sonu için enlem ve boylamlara sahip ızgara hücrelerine entegre edilir. Her bir ızgara hücresi arasındaki mesafeyi hesaplamak ve ona atamak için orta noktaları ( Lon_M, Lat_M) kullanıyorsunuz Distance_betweeen.

```{r}
# Data prep for temporal interval join
Sv <- Sv_layer1 %>% 
    mutate(Distance_between = c(0,
                                geosphere::distHaversine(cbind(Lon_M[-n()], Lat_M[-n()]),
                                                         cbind(Lon_M[  -1], Lat_M[  -1]))),
           Distance_along = cumsum(Distance_between)) %>%
    na_if(-999) %>% 
    mutate(Time_interval = interval(Datetime_start, Datetime_end))

# Glimpse the data
glimpse(Sv)
```
# **7.AŞAMA**

7. UZAMSAL OLAMIYOR MUSUNUZ? ZAMANSAL GİT

**AÇIKLAMALAR**

Akustik dosyada derinlik bilgisi yok. Bu tam olarak doğru değil. Bu 78 değişkenden biri ortalama derinlikti, ancak ortalamanın bir ortalamasıydı ve bottom_clean'da sahip olduğumuz derinlik verileri kadar doğru değildi.

İki veri setinin farklı uzamsal çözünürlüklere sahip olduğunu da fark etmiş olabilirsiniz. Derinlik verilerini bottom_clean'den nasıl çekip akustik verilerle birleştirebiliriz? Bunu yapmanın birkaç farklı uzamsal yolu var, ancak uzamsal paketlerde çalışmadığımız için, bottom_clean'dan hangi veri noktalarının az önce oluşturduğumuz Zaman aralığı, Zaman aralığı içinde olduğunu bulmak için bir fonksiyon yazacağız.


**TALİMATLAR**

SvTemiz dip verilerindeki her noktaya doğru uzamsal aralığı atayın .​

İnceleyin get_Interval_by_time().​

Create trackline_intervaliçinde bottom_cleankullanarak map_dbl().​

İlk 15 satırı inceleyin. Sütuna dikkat edin trackline_interval.

get_Interval_by_time()Spatial_intervalakustik verilerden alt verilerdeki akustik zamansal aralıklarla düşen noktalara değerleri atayan bir işlevdir Time_interval.

```{r}
# Name the function
get_Interval_by_time <- function(bottom_data){
  res <- Sv$Spatial_interval[bottom_data %within% Sv$Time_interval]
  if(length(res)==0) return(NA)         # dealing with NAs
  return(res)
}
 
# Map the track line interval value to the bottom_clean data
bottom_spatial_interval_segments <- bottom_clean  %>% 
    mutate(trackline_interval = purrr::map_dbl(date_time, get_Interval_by_time))

# Inspect the first 15 rows
head(bottom_spatial_interval_segments, 15)

```


# **8.AŞAMA**

BİR ARALIĞIN DERİNLİĞİ
**AÇIKLAMALAR**
Artık bottom_spatial_interval_segments'teki her veri noktasına atanan akustik verilerden uzamsal izleme çizgisi aralıklarına sahip olduğumuza göre, iz çizgisi boyunca her bir izleme çizgisi_ aralığı için ortalama derinliği hesaplayabiliriz. Ardından, Spatial_interval ve trackline_interval üzerindeki iki veri kümesini birleştirmemiz gerekecek.​
​
Yalnızca ilk derinlik katmanına (0 ila 250 m) baktığımızı unutmayın. Tüm su sütunu üzerine entegre edilmiş verileri çizdiğimizi ima etmek istemediğimiz için, 250 m'den büyük derinlikleri 250 ile değiştireceğiz.

**TALİMATLAR**

Her bir iz hattı aralığı için ortalama derinliği özetleyin.​

Grup bottom_spatial_interval_segmentstarafından trackline_intervalve her aralık için ortalama derinliği özetler.​

bottom_intervalsAkustik verilere katılın ve depth_plot250 metreden büyük her derinlik değerini 250 ile değiştiren yeni bir değişken oluşturun .​

Yeni veri kümesine bir göz atın.

```{r}
# Group bottom_clean and calculate the mean depth

bottom_intervals<-bottom_spatial_interval_segments %>%
  group_by(trackline_interval) %>%
  summarize(depth_mean=mean(depth)) %>%
  ungroup()

#Join the bottom intervals data to the acoustic data

Sv_and_depth<-Sv %>%
  left_join(bottom_intervals,by=c("Spatial_interval"="trackline_interval")) %>%
  mutate(depth_plot=ifelse(depth_mean >=250,250,depth_mean))

#Glimpse the data

glimpse(Sv_and_depth)
```

# **9.AŞAMA**
9. HEPSİNİ BİR ARAYA GETİRMEK

**AÇIKLAMALAR**

Woohoo! Çok fazla veri tartışması yaptık!​
​
Şimdi, yüksek ve düşük yoğunluklu balıkların ray hattı boyunca nerede olduğunu bulmak için Sv_mean'ı batimetriye (derinlik_lot) göre çizme zamanı. Y eksenlerimiz iki farklı ölçekte olduğundan, iki grafik oluşturacağız ve onları tek bir şekle yerleştirmek için patchwork paketini tekrar kullanacağız.

**TALİMATLAR**

Woohoo! Çok fazla veri tartışması yaptık!​
​
Şimdi, yüksek ve düşük yoğunluklu balıkların ray hattı boyunca nerede olduğunu bulmak için Sv_mean'ı batimetriye (derinlik_lot) göre çizme zamanı. Y eksenlerimiz iki farklı ölçekte olduğundan, iki grafik oluşturacağız ve onları tek bir şekle yerleştirmek için patchwork paketini tekrar kullanacağız.

İhtiyacınız olan tüm veriler burada Sv_and_depth.

```{r}
# Top panel

Sv_mean_plot<-ggplot(Sv_and_depth, aes(Distance_along,Sv_mean))+
  geom_line()+
  labs(y=expression(mean~volume~backscatter~s[v]~(dB)))+
  theme(axis.title.x=element_blank())

# Bottom panel

bathymetry<-ggplot(Sv_and_depth,aes(Distance_along,depth_plot))+
  geom_line(size=0.5)+
  scale_y_reverse()+
  labs(x="Distance along trackline (m)",y="Depth(m)")

# Display the two panels in one figure

Sv_mean_plot/bathymetry
```




# **10.AŞAMA**

10. PEKİ BALIKLAR NEREDE?

**AÇIKLAMALAR**

Güzel görünen arsa!​
​
Tüm akustik geri saçılımın sadece yüzme kesesi olan balıklardan geldiğini ve daha büyük geri saçılmanın daha yüksek balık yoğunluklarını gösterdiğini varsayarsak, bu yol hattındaki balıkların çoğu nerede?

**TALİMATLAR**

200 mx 250 m ızgara hücresi başına en fazla balığa sahip ray hattının hangi bölümü?​

Bir karakter dizisi kullanarak, izleme çizgisinin hangi bölümünde en fazla balığın olduğunu belirtin.​

Seçenekler: Shelf, Shelf Break, Offshore​

​
​

Projeyi bitirdiğiniz için tebrikler!

```{r}
# Where do you think the fish are along this track line?

# Options:Shelf,Shelf Break ,Offshore

(where_are_the_fishes<-"Shelf")
```






